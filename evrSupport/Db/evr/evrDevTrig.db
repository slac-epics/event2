#
# evrDevTrig.db
#
# Need one instance for each trigger output you're controlling
# For PMC 230 EVR's w/ no transition board, there are just the
# three on the front panel.
# For VME 230 EVR's w/ no transition board, there are eight
# For EVR's w/ a transition board, up to 16 more triggers are available
#
# Required macros:
#	EVR  - EVR PV prefix
#	TRIG - Trigger PV prefix
#	TYPE - DG or OT (Extended Delay Pulse Generator or OTP Pulse Generator)
#	N	 - Trigger number (0, 1, 2, ...)
#	TCTL - Trigger control (enable) field, one of DG0E, DG1E, DG2E, OTP0, ..., OTPD

# Optional macros:
#	DESC - Trigger description
#	DES	 - Trigger TDES, desired delay value, default 0
#	WID	 - Initial Trigger width, default 100ns
#	POL	 - Initial Trigger polarity, default 0 (NORMAL)
#	CTL	 - Initial Trigger enable, default 1 (Enabled)
#	ACTV - Invariant Trigger Activate, default 1
#	SYS  - EVG System specifier, default SYS0
#	DRVH - High limit of desired delay, default  2.14748E09
#	DRVL - Low  limit of desired delay, default -2.14748E09
#

#
# Primary trigger controls are:
# $(TRIG):TEC	- Trigger event code
# $(TRIG):TCTL	- Trigger output enable/disable
# $(TRIG):TPOL	- Trigger output polarity
# $(TRIG):TWID	- Trigger width in ns
# $(TRIG):TDES	- Trigger desired delay in ns
#

# New record to support the concept and U/I for Locking the trigger timing
# This version is purely a visual indicator.
# Subsequent versions will likely provide some level of db protection as well.
record( bo, "$(TRIG):LOCKED" )
{
	field( ZNAM, "Unlocked" )
	field( ONAM, "Locked" )
}

# Trigger type, set in substitution file
record( bo, "$(TRIG):TYPE" )
{
	field( DOL,  "$(TYPE)" )
	field( OMSL, "closed_loop" )
	field( ZNAM, "DG" )
	field( ONAM, "OT" )
	field( PINI, "YES" )
	info( autosaveFields, "DESC" )
}

# Trigger event code
record( longout, "$(TRIG):TEC" )
{
	field( DESC, "Trigger's Event code" )
	field( OUT,  "$(TRIG):EC_NAME.EVNT" )
	field( FLNK, "$(TRIG):EC_NAME PP MS" )
	info( autosaveFields, "DESC VAL" )
}

# Trigger enable/disable record
record( bo, "$(TRIG):TCTL" )
{
	field( DESC, "Trigger Control" )
	field( DTYP, "Soft Channel" )
	field( OUT, "$(EVR):CTRL.$(TCTL) PP" )
	field( ZNAM, "Disabled" )
	field( ONAM, "Enabled" )
	field( OMSL, "supervisory" )
	field( VAL, "$(CTL=1)" )
	field( PINI, "YES" )
	info( autosaveFields, "DESC VAL ZNAM ONAM ZSV OSV" )
}

# Trigger polarity
record( bo, "$(TRIG):TPOL" )
{
	field( DESC, "Trigger Polarity" )
	field( DTYP, "Soft Channel" )
	field( OUT, "$(EVR):CTRL.$(TYPE)$(N)P PP" )
	field( ZNAM, "Normal" )
	field( ONAM, "Inverted" )
	field( OMSL, "supervisory" )
	field( VAL, "$(POL=0)" )
	field( PINI, "YES" )
	info( autosaveFields, "DESC VAL ZNAM ONAM ZSV OSV" )
}

# Trigger width
record( ao, "$(TRIG):TWID" )
{
	field( DESC, "Trigger Width" )
	field( DTYP, "Raw Soft Channel" )
	field( OMSL, "supervisory" )
	field( LINR, "SLOPE" )
	field( EGU, "ns" )
	field( HOPR, "1000000000" )
	field( DRVH, "1000000000" )
	field( ESLO, "8.403361345" )
	field( VAL, "$(WID=100)" )
	field( MDEL, "-1" )
	field( FLNK, "$(TRIG):BW_DIS2" )
	field( PINI, "YES" )
	info( autosaveFields, "DESC EGU HHSV HIGH HIHI HSV LLSV LOLO LOW LSV PREC VAL" )
}

# Desired trigger delay as an offset relative
# to $(EVR):TREF, the trigger reference time
# Initialized to a negative number to force TDES to be back calculated
# from the pulse generator settings when no autosave value is found.
# Useful when transitioning to invariant timing.
record( ao, "$(TRIG):TDES" )
{
	field( DESC, "Desired Trig Delay" )
	field( DTYP, "Raw Soft Channel" )
	field( OMSL, "supervisory" )
	field( LINR, "SLOPE" )
	field( EGU, "ns" )
	field( PREC, "1" )
	field( HOPR, "$(DRVH=2.14748E09)" )
	field( LOPR, "$(DRVL=-2.14748E09)" )
	field( DRVH, "$(DRVH=2.14748E09)" )
	field( DRVL, "$(DRVL=-2.14748E09)" )
	field( ESLO, "8.403361345" )
	field( VAL, "$(DES=-1e9)" )
	field( MDEL, "-1" )
	field( PINI, "YES" )
	field( LSV,  "MINOR" )
	field( FLNK, "$(TRIG):TDLY_NS" )
	info( autosaveFields, "DESC EGU HHSV HIGH HIHI HSV LLSV LOLO LOW LSV PREC VAL" )
}

# Trigger event code
record( longout, "$(TRIG):EC_RBV" )
{
	field( DESC, "Trigger's Event code" )
	field( OMSL, "closed_loop" )
	field( DOL,  "$(TRIG):LSUB_EVSEL CPP MS" )
	field( FLNK, "$(TRIG):BW_EC_SEQ" )
	info( autosaveFields, "DESC" )
}

# Disable the forward event code set sequence
# while updating from a backward fetch of the event code
# from an enabled ctrl record
# Note: Do not use any delays in this sequence or the
# record will still be active if new event code updates
# come through.  That is why the FW_EC_SEQ_ENAB is
# re-enabled in a separate PV.
record( seq, "$(TRIG):BW_EC_SEQ" )
{
	field( DOL1, "0" )
	field( LNK1, "$(TRIG):FW_EC_SEQ_ENAB PP NMS" )

	field( DOL2, "$(TRIG):EC_RBV NPP NMS" )
	field( LNK2, "$(TRIG):TEC PP NMS" )

	field( FLNK, "$(TRIG):FW_EC_SEQ_REENABLE PP NMS" )
	info( autosaveFields, "DESC" )
}

record( seq, "$(TRIG):FW_EC_SEQ_REENABLE" )
{
	field( DLY1, "0.25" )
	field( DOL1, "1" )
	field( LNK1, "$(TRIG):FW_EC_SEQ_ENAB PP NMS" )
	info( autosaveFields, "DESC" )
}

# Tick count for the trigger
# Corresponds to the number of 8.4ns EVR time slots
# between the fiducial event code 1 and the current
# trigger event code.
# Value set by record $(TRIG):ASUB_LKUOFFSET
record( ai, "$(TRIG):TOFFSET" )
{
	field( DESC, "Tick cnt for cur EC" )
	field( PINI, "NO" )
	field( EGU,  "ticks" )
	field( FLNK, "$(TRIG):TOFFSET_NS" )
	field( LOW,  "-1e-9" )
	field( LSV,  "MINOR" )
}

record( calc, "$(TRIG):TOFFSET_NS" )
{
	field( DESC, "Offset in ns for ec" )
	field( EGU,  "ns" )
	field( CALC, "A*B" )
	field( INPA, "$(TRIG):TOFFSET NPP MS" )
	field( INPB, "8.403361345" )
	field( FLNK, "$(TRIG):TDES" )
}

# This PV looks up the tick offset of
# the current event code for this trigger
# The event code is read by $(TRIG):LSUB_EVSEL and
# this record processes each time LSUB_EVSEL updates
record( aSub, "$(TRIG):ASUB_LKUOFFSET" )
{
	field( DESC, "Offset lookup" )
	field( SCAN, "Passive" )
	field( PINI, "YES" )
	field( INAM, "aSubEvOffsetInit" )
	field( SNAM, "aSubEvOffset" )
	field( INPA, "$(TRIG):LSUB_EVSEL.VAL NPP MS" )
	field( INPB, "$(ACTV=1)" )
	field( INPC, "EVNT:$(SYS=SYS0):1:DELAY CPP MS" )
	field( INPD, "0" )
	field( FTA, "LONG" )
	field( FTB, "LONG" )
	field( FTC, "LONG" )
	field( FTD, "LONG" )
	field( NOC, "256" )
	field( OUTA, "$(TRIG):TOFFSET.VAL PP MS" )
	field( FTVA, "LONG" )
#	field( FLNK, "$(TRIG):TDES" ) # Needed?
}

# PV to read currently assigned event code
# Processes whenever any of the event controls
# posts a CA monitor event, which will happen
# if their event code is changed.
# Uses the LSUB_TRGSEL value via input Z to specify
# which control record's event code number to read
record( longSub, "$(TRIG):LSUB_EVSEL" )
{
	field( DESC, "Event Code Read" )
	field( SCAN, "Passive" )
	field( INAM, "lsubEvSelInit" )
	field( SNAM, "lsubEvSel" )
	field( INPA, "$(TRIG):EVENTCTRL.ENM CPP NMS" )
	field( INPB, "$(EVR):EVENT1CTRL.ENM CPP NMS" )
	field( INPC, "$(EVR):EVENT2CTRL.ENM CPP NMS" )
	field( INPD, "$(EVR):EVENT3CTRL.ENM CPP NMS" )
	field( INPE, "$(EVR):EVENT4CTRL.ENM CPP NMS" )
	field( INPF, "$(EVR):EVENT5CTRL.ENM CPP NMS" )
	field( INPG, "$(EVR):EVENT6CTRL.ENM CPP NMS" )
	field( INPH, "$(EVR):EVENT7CTRL.ENM CPP NMS" )
	field( INPI, "$(EVR):EVENT8CTRL.ENM CPP NMS" )
	field( INPJ, "$(EVR):EVENT9CTRL.ENM CPP NMS" )
	field( INPK, "$(EVR):EVENT10CTRL.ENM CPP NMS" )
	field( INPL, "$(EVR):EVENT11CTRL.ENM CPP NMS" )
	field( INPM, "$(EVR):EVENT12CTRL.ENM CPP NMS" )
	field( INPN, "$(EVR):EVENT13CTRL.ENM CPP NMS" )
	field( INPO, "$(EVR):EVENT14CTRL.ENM CPP NMS" )
	field( INPZ, "$(TRIG):LSUB_TRGSEL.VAL PP MS" )
	field( FLNK, "$(TRIG):ASUB_LKUOFFSET" )
}

# This PV examines each of the 14 control records to find
# the first one which is enabled for this trigger's output
# It's value is 0 if the $(TRIG):EVENTCTRL is enabled,
# 1 if EVENT1CTRL is enabled, 2 for EVENT2CTRL, ...
record( longSub, "$(TRIG):LSUB_TRGSEL" )
{
	field( DESC, "Delay Selector" )
	field( SCAN, "Passive" )
	field( PINI, "YES" )
	field( INAM, "lsubTrigSelInit" )
	field( SNAM, "lsubTrigSel" )
	field( INPA, "$(TRIG):EVENTCTRL.OUT$(N) CPP NMS" )
	field( INPB, "$(EVR):EVENT1CTRL.OUT$(N) CPP NMS" )
	field( INPC, "$(EVR):EVENT2CTRL.OUT$(N) CPP NMS" )
	field( INPD, "$(EVR):EVENT3CTRL.OUT$(N) CPP NMS" )
	field( INPE, "$(EVR):EVENT4CTRL.OUT$(N) CPP NMS" )
	field( INPF, "$(EVR):EVENT5CTRL.OUT$(N) CPP NMS" )
	field( INPG, "$(EVR):EVENT6CTRL.OUT$(N) CPP NMS" )
	field( INPH, "$(EVR):EVENT7CTRL.OUT$(N) CPP NMS" )
	field( INPI, "$(EVR):EVENT8CTRL.OUT$(N) CPP NMS" )
	field( INPJ, "$(EVR):EVENT9CTRL.OUT$(N) CPP NMS" )
	field( INPK, "$(EVR):EVENT10CTRL.OUT$(N) CPP NMS" )
	field( INPL, "$(EVR):EVENT11CTRL.OUT$(N) CPP NMS" )
	field( INPM, "$(EVR):EVENT12CTRL.OUT$(N) CPP NMS" )
	field( INPN, "$(EVR):EVENT13CTRL.OUT$(N) CPP NMS" )
	field( INPO, "$(EVR):EVENT14CTRL.OUT$(N) CPP NMS" )
	field( FLNK, "$(TRIG):LSUB_EVSEL" )
}

# Forward trigger delay seqence enable calculation
# Input A is used for temporary disable of the FW_TDES sequence
# Processed on demand by FW_TDES_SEQ
record( calcout, "$(TRIG):FW_TDES_SEQ_ENAB_CALC" )
{
	field( INPA, "1" )
	field( INPB, "$(TRIG):LSUB_TRGSEL.SEVR NPP NMS" )
	field( INPC, "$(TRIG):TDES.SEVR NPP NMS" )
	field( INPD, "$(TRIG):TDLY NPP MS" )
	field( INPE, "$(TRIG):ASUB_LKUOFFSET.SEVR NPP NMS" )
	field( CALC, "A&&(B==0)&&(C==0)&&(D>=0)&&(E==0)" )
	field( OUT,  "$(TRIG):FW_TDES_SEQ_ENAB PP NMS" )
}

record( bo, "$(TRIG):FW_TDES_SEQ_ENAB" )
{
	field( ZNAM, "Disabled" )
	field( ONAM, "Enabled" )
}

# Sequence for forward delay updates
# No delays in this record, see the re-enable
record( seq, "$(TRIG):FW_TDES_SEQ" )
{
	field( SDIS, "$(TRIG):FW_TDES_SEQ_ENAB_CALC PP" )
	field( DISV, "0" )
	field( DESC, "Update delay seq" )

#   Disable the BW_TDES_SEQ while we do the FW_TDES_SEQ
	field( DOL1, "0" )
	field( LNK1, "$(TRIG):BW_TDES_SEQ_ENAB_CALC.A PP MS" )

	field( DOL2, "$(TRIG):TDLY NPP MS" )
	field( LNK2, "$(TRIG):FW_TDES_TICK_CALC PP NMS" )

	field( FLNK, "$(TRIG):BW_TDES_SEQ_REENABLE PP NMS" )
	info( autosaveFields, "DESC" )
}

# Reenable after a short delay
record( seq, "$(TRIG):BW_TDES_SEQ_REENABLE" )
{
	field( DLY1, "0.25" )
	field( DOL1, "1" )
	field( LNK1, "$(TRIG):BW_TDES_SEQ_ENAB_CALC.A PP NMS" )
	info( autosaveFields, "DESC" )
}

# Backward trigger delay seqence enable calculation
# Input A is used for temporary disable of the BW_TDES sequence
# Processed on demand by BW_TDES_SEQ
record( calcout, "$(TRIG):BW_TDES_SEQ_ENAB_CALC" )
{
	field( INPA, "1" )
	field( INPB, "$(TRIG):LSUB_TRGSEL.SEVR NPP NMS" )
	field( CALC, "A && (B==0)" )
	field( OUT,  "$(TRIG):BW_TDES_SEQ_ENAB PP NMS" )
}

record( bo, "$(TRIG):BW_TDES_SEQ_ENAB" )
{
	field( ZNAM, "Disabled" )
	field( ONAM, "Enabled" )
}

# Sequence for backward delay updates
# No delays in this record, see the re-enable
record( seq, "$(TRIG):BW_TDES_SEQ" )
{
	field( SDIS, "$(TRIG):BW_TDES_SEQ_ENAB_CALC PP" )
	field( DISV, "0" )
	field( DESC, "Backward delay seq" )

#   Disable the FW_TDES_SEQ while we do the BW_TDES_SEQ
	field( DOL1, "0" )
	field( LNK1, "$(TRIG):FW_TDES_SEQ_ENAB_CALC.A PP MS" )

	field( DOL2, "$(TRIG):BW_TDES NPP MS" )
	field( LNK2, "$(TRIG):TDES PP NMS" )

	field( FLNK, "$(TRIG):FW_TDES_SEQ_REENABLE PP NMS" )
	info( autosaveFields, "DESC" )
}

# Reenable after a short delay
record( seq, "$(TRIG):FW_TDES_SEQ_REENABLE" )
{
	field( DOL1, "1" )
	field( DLY1, "0.25" )
	field( LNK1, "$(TRIG):FW_TDES_SEQ_ENAB_CALC.A PP MS" )
	info( autosaveFields, "DESC" )
}

# This PV computes the Trigger Delay in ticks
record( calcout, "$(TRIG):TDLY" )
{
	field( DESC, "Trigger EVR Delay" )
	field( INPA, "$(TRIG):TDLY_NS NPP MS" )
	field( INPB, "8.403361345" )
	field( CALC, "FLOOR((A/B)+0.5)" )
	field( EGU,  "ticks" )
	field( LOW,  "-1e-9" )
	field( LSV,  "MINOR" )
	field( OUT,  "$(TRIG):TDES_TICKS PP NMS" )
}

# This record shows the desired delay in ticks
# (May someday allow setting desired delay in ticks,
#  but for now is closed_loop to avoid DB process
#  chain errors.)
record( ao, "$(TRIG):TDES_TICKS"	)
{
	field( DOL,  "$(TRIG):TDLY NPP MS" )
	field( OMSL, "closed_loop" )
	field( EGU,  "ticks" )
	field( FLNK, "$(TRIG):FW_TDES_SEQ" )
}

record( calcout, "$(TRIG):FW_TDES_TICK_CALC"	)
{
	field( INPA, "$(TRIG):TDLY NPP NMS" )
	field( INPB, "$(TRIG):LSUB_EVSEL.SEVR NPP NMS" )
	field( CALC, "(A>=0)&&(B==0)" )
	field( OOPT, "When Non-zero" )
	field( DOPT, "Use OCAL" )
	field( OCAL, "A" )
	field( OUT,  "$(EVR):CTRL.$(TYPE)$(N)D PP NMS" )
	field( EGU,  "ticks" )
}

# This PV calculates the additional delay in ns
# after the event code before the trigger is generated
record( calc, "$(TRIG):TDLY_NS" )
{
	field( DESC, "Trigger Delay" )
	field( CALC, "A+B-(C*D)" )
	field( INPA, "$(TRIG):TDES.VAL NPP MS" )
	field( INPB, "$(EVR):TREF CPP MS" )
	field( INPC, "$(TRIG):TOFFSET.VAL NPP MS" )
	field( INPD, "8.403361345" )
	field( EGU,  "ns" )
	field( HOPR, "1000000000" )
	field( PREC, "1" )
	field( FLNK, "$(TRIG):TDLY" )
	field( LOW,  "-1e-9" )
	field( LSV,  "MINOR" )
}

# Update TDES.LOW based on 0 tick delay
# Setting at 0.01 lower than calculated to avoid
# flagging 0 delays on EC 140 due to rounding errors
record( calcout, "$(TRIG):TDES_CALC_LOW" )
{
	field( DESC, "TDES low limit calc" )
	field( CALC, "A*B-C-0.01" )
	field( INPA, "$(TRIG):TOFFSET.VAL CPP NMS" )
	field( INPB, "8.403361345" )
	field( INPC, "$(EVR):TREF CPP MS" )
	field( EGU,  "ns" )
	field( PREC, "2" )
	field( OUT,  "$(TRIG):TDES.LOW PP NMS" )
}

# Grab the delay tick count for easy edm viewing w/ EGU of ticks
record( longin, "$(TRIG):BW_TDLY" )
{
	field( DESC, "Tick count from delay gen" )
	field( INP,  "$(EVR):CTRL.$(TYPE)$(N)D CPP MS" )
	field( EGU,  "ticks" )
	field( FLNK, "$(TRIG):BW_TDLY_NS" )
}

# Compute time delay in ns after the event code
record( calc, "$(TRIG):BW_TDLY_NS" )
{
	field( DESC, "Backward delay after EC" )
	field( SCAN, "Passive" )
	field( CALC, "A*B" )
	field( INPA, "$(TRIG):BW_TDLY NPP MS" )
	field( INPB, "8.403361345" )
	field( EGU,  "ns" )
	field( PREC, "2" )
	field( FLNK, "$(TRIG):BW_TDES" )
}

# Compute desired delay relative to TREF (ns)
record( calc, "$(TRIG):BW_TDES" )
{
	field( DESC, "Backward TDES calc" )
	field( SCAN, "Passive" )
	field( CALC, "(A+B)*C-D" )
	field( INPA, "$(TRIG):TOFFSET.VAL NPP MS" )
	field( INPB, "$(TRIG):BW_TDLY NPP MS" )
	field( INPC, "8.403361345" )
	field( INPD, "$(EVR):TREF NPP MS" )
	field( EGU,  "ns" )
	field( PREC, "2" )
	field( FLNK, "$(TRIG):BW_TDES_SEQ" )
}

record( seq, "$(TRIG):PROP_SEQ2" )
{
	field( PINI, "YES" )
	field( DLY1, "15" )
	field( DOL1, "1" )
	field( LNK1, "$(TRIG):FW_SEQ2.DLY1" )
}

record( ao, "$(TRIG):TCON" )
{
	field( DESC, "Trigger Delay" )
	field( EGU, "ns" )
	field( HOPR, "$(DRVH=2.14748E09)" )
	field( LOPR, "$(DRVL=-2.14748E09)" )
	field( DRVH, "$(DRVH=2.14748E09)" )
	field( DRVL, "$(DRVL=-2.14748E09)" )
	field( PINI, "YES" )
	field( MDEL, "-1" )
	info( autosaveFields, "DESC EGU HHSV HIGH HIHI HSV LLSV LOLO LOW LSV PREC VAL" )
}

record( fanout, "$(TRIG):TINI" )
{
	field( DESC, "Trigger Init" )
	field( PINI, "YES" )
	field( LNK1, "$(TRIG):TDES PP" )
	field( LNK2, "$(TRIG):TWID PP" )
	field( LNK3, "$(TRIG):TPOL PP" )
	field( LNK4, "$(TRIG):TCTL PP" )
}

record( seq, "$(TRIG):TPOL_ITNSEQ" )
{
	field( DLY1, "0" )
	field( DOL1, "0" )
	field( LNK1, "$(TRIG):TPOL_ITN.DISV" )

	field( DLY2, ".5" )
	field( DOL2, "1" )
	field( LNK2, "$(TRIG):TPOL_ITN.DISV" )
}

record( bo, "$(TRIG):TPOL_ITN" )
{
	field( SCAN, "Passive" )
	field( DTYP, "Soft Channel" )
	field( OMSL, "closed_loop" )
	field( DOL,  "$(EVR):CTRL.$(TYPE)$(N)P CPP NMS" )
	field( OUT,  "$(TRIG):TPOL.VAL PP" )
	field( ZNAM, "Normal" )
	field( ONAM, "Inverted" )
	field( FLNK, "$(TRIG):TPOL_ITNSEQ" )
}

record( seq, "$(TRIG):TCTL_ITNSEQ" )
{
	field( DLY1, "0" )
	field( DOL1, "0" )
	field( LNK1, "$(TRIG):TCTL_ITN.DISV" )

	field( DLY2, ".5" )
	field( DOL2, "1" )
	field( LNK2, "$(TRIG):TCTL_ITN.DISV" )
}

record( bo, "$(TRIG):TCTL_ITN" )
{
	field( SCAN, "Passive" )
	field( DTYP, "Soft Channel" )
	field( OMSL, "closed_loop" )
	field( DOL,  "$(EVR):CTRL.$(TCTL) CPP NMS" )
	field( OUT,  "$(TRIG):TCTL.VAL PP" )
	field( ZNAM, "Disabled" )
	field( ONAM, "Enabled" )
	field( FLNK, "$(TRIG):TCTL_ITNSEQ" )
}

record( ao, "$(TRIG):BW_DIS2" )
{
	field( FLNK, "$(TRIG):FW_FOUT2" )
	field( OUT,  "$(TRIG):BW_SW2.VAL PP" )
	field( DOL,  "1" )
	field( OMSL, "closed_loop" )
	field( SDIS, "$(TRIG):FW_SW2.VAL" )
}

record( ai, "$(TRIG):FW_SW2" )
{
}

record( seq, "$(TRIG):BW_SEQ2" )
{
	field( DLY1, "1." )
	field( DOL1, "0" )
	field( LNK1, "$(TRIG):FW_SW2.VAL PP" )
}

record( fanout, "$(TRIG):FW_FOUT2" )
{
	field( SDIS, "$(TRIG):FW_SW2.VAL" )
	field( FLNK, "$(TRIG):FW_SEQ2" )
	field( LNK1, "$(TRIG):TWID2" )
}

record( seq, "$(TRIG):FW_SEQ2" )
{
	field( DLY1, "15" )
	field( DOL1, "0" )
	field( LNK1, "$(TRIG):BW_SW2.VAL PP" )
}

record( fanout, "$(TRIG):BW_FOUT2" )
{
	field( FLNK, "$(TRIG):BW_SEQ2" )
	field( LNK1, "$(TRIG):BW_TWID" )
}

record( ai, "$(TRIG):BW_SW2" )
{
}

record( ao, "$(TRIG):BW_TWID" )
{
	field( SDIS, "$(TRIG):BW_SW2.VAL" )
	field( OUT, "$(TRIG):TWID.VAL PP" )
	field( DOL, "$(TRIG):BW_TWIDCALC.VAL" )
	field( OMSL, "closed_loop" )
}

record( ao, "$(TRIG):FW_DIS2" )
{
	field( FLNK, "$(TRIG):BW_FOUT2" )
	field( OUT, "$(TRIG):FW_SW2.VAL PP" )
	field( DOL, "1" )
	field( OMSL, "closed_loop" )
	field( SDIS, "$(TRIG):BW_SW2.VAL" )
}

record( ao, "$(TRIG):TWID2" )
{
	field( DESC, "Trigger Width" )
	field( DTYP, "Raw Soft Channel" )
	field( OUT, "$(EVR):CTRL.$(TYPE)$(N)W PP" )
	field( OMSL, "closed_loop" )
	field( LINR, "SLOPE" )
	field( EGU, "ns" )
	field( PREC, "1" )
	field( HOPR, "1000000000" )
	field( DRVH, "1000000000" )
	field( ESLO, "8.403361345" )
	field( VAL, "$(WID=100)" )
	field( MDEL, "-1" )
	field( SDIS, "$(TRIG):FW_SW2.VAL" )
	field( DOL, "$(TRIG):TWID.VAL" )
}

# Grab the width tick count for easy edm viewing w/ EGU of ticks
record( longin, "$(TRIG):BW_TWID_TICKS" )
{
	field( DESC, "Width from delay gen" )
	field( INP,  "$(EVR):CTRL.$(TYPE)$(N)W CPP MS" )
	field( EGU,  "ticks" )
	field( FLNK, "$(TRIG):BW_TWIDCALC" )
}

record( calc, "$(TRIG):BW_TWIDCALC" )
{
	field( INPA, "$(TRIG):BW_TWID_TICKS NPP MS" )
	field( INPB, "8.403361345" )
	field( CALC, "A*B" )
	field( EGU,  "ns" )
	field( PREC, "1" )
	field( FLNK, "$(TRIG):FW_DIS2" )
}

# Records for fetching the trigger's event code, count, rate, and event name.
record( longSub, "$(TRIG):CNT" )
{
	field( DESC, "Trigger Count" )
	field( SNAM, "evrTimeEvent" )
	field( BRSV, "INVALID" )
	field( INPA, "$(TRIG):LSUB_EVSEL NPP MS" )
	field( SCAN, ".1 second" )
}

record( sub, "$(TRIG):RATE" )
{
	field( DESC, "Trigger Rate" )
	field( SNAM, "evrTimeRate" )
	field( BRSV, "INVALID" )
	field( SCAN, "Event" )
	field( EVNT, "121" )
	field( PRIO, "MEDIUM" )
	field( INPE, "$(TRIG):LSUB_EVSEL NPP MS" )
	field( EGU,  "Hz" )
	field( PREC, "1" )
	field( LOW,  "0" )
	field( LSV,  "MINOR" )
}

# This record returns a copy of the event code name
# for the event code specified by it's EVNT field.
# Update that field dynamically to fetch the name
# for a different event code.
record( stringin, "$(TRIG):EC_NAME" )
{
	field( DESC,  "Get event code name" )
	field( DTYP,  "MRF Event Receiver" )
	field( INP,   "#C$(CARD) S0 @" )
	field( EVNT,  "0" )
	field( FLNK,  "$(TRIG):FW_EC_SEQ" )
}

record( bo, "$(TRIG):FW_EC_SEQ_ENAB" )
{
	field( ZNAM, "Disabled" )
	field( ONAM, "Enabled" )
}

# The foward event code sequence is now an aSub
# record, which copies INPA to OUTA, INPB to OUTB, ...
# It's configured to write the current trigger event code
# to the trigger's dedicated erevent EVENTCTRL event code field.
# It also enables that EVENTCTRL record and turns off any
# other EVENT[1..14]CTRL records that are enabled.
record( aSub, "$(TRIG):FW_EC_SEQ" )
{
	field( SDIS, "$(TRIG):FW_EC_SEQ_ENAB" )
	field( DISV, "0" )
	field( DESC, "Output Selector" )
	field( SCAN, "Passive" )
	field( PINI, "NO" )
	field( INAM, "asubCopyInToOutInit" )
	field( SNAM, "asubCopyInToOut" )
	field( EFLG, "ON CHANGE" )

	field( FTA,  "ULONG" )
	field( FTVA, "ULONG" )
	field( INPA, "$(TRIG):TEC NPP NMS" )
	field( OUTA, "$(TRIG):EVENTCTRL.ENM NPP NMS" )

	field( FTB,  "ULONG" )
	field( FTVB, "ULONG" )
	field( INPB, "1" )
	field( OUTB, "$(TRIG):EVENTCTRL.ENAB NPP NMS" )

	field( FTC,  "ULONG" )
	field( FTVC, "ULONG" )
	field( INPC, "1" )
	field( OUTC, "$(TRIG):EVENTCTRL.OUT$(N)  PP  NMS" )

    # The inputs for these are all zero
	field( OUTD, "$(EVR):EVENT1CTRL.OUT$(N)  CA NMS" )
	field( OUTE, "$(EVR):EVENT2CTRL.OUT$(N)  CA NMS" )
	field( OUTF, "$(EVR):EVENT3CTRL.OUT$(N)  CA NMS" )
	field( OUTG, "$(EVR):EVENT4CTRL.OUT$(N)  CA NMS" )
	field( OUTH, "$(EVR):EVENT5CTRL.OUT$(N)  CA NMS" )
	field( OUTI, "$(EVR):EVENT6CTRL.OUT$(N)  CA NMS" )
	field( OUTJ, "$(EVR):EVENT7CTRL.OUT$(N)  CA NMS" )
	field( OUTK, "$(EVR):EVENT8CTRL.OUT$(N)  CA NMS" )
	field( OUTL, "$(EVR):EVENT9CTRL.OUT$(N)  CA NMS" )
	field( OUTM, "$(EVR):EVENT10CTRL.OUT$(N) CA NMS" )
	field( OUTN, "$(EVR):EVENT11CTRL.OUT$(N) CA NMS" )
	field( OUTO, "$(EVR):EVENT12CTRL.OUT$(N) CA NMS" )
	field( OUTP, "$(EVR):EVENT13CTRL.OUT$(N) CA NMS" )
	field( OUTQ, "$(EVR):EVENT14CTRL.OUT$(N) CA NMS" )

	field( INPD, "0" ) field( FTD, "ULONG" ) field( FTVD, "ULONG" )
	field( INPE, "0" ) field( FTE, "ULONG" ) field( FTVE, "ULONG" )
	field( INPF, "0" ) field( FTF, "ULONG" ) field( FTVF, "ULONG" )
	field( INPG, "0" ) field( FTG, "ULONG" ) field( FTVG, "ULONG" )
	field( INPH, "0" ) field( FTH, "ULONG" ) field( FTVH, "ULONG" )
	field( INPI, "0" ) field( FTI, "ULONG" ) field( FTVI, "ULONG" )
	field( INPJ, "0" ) field( FTJ, "ULONG" ) field( FTVJ, "ULONG" )
	field( INPK, "0" ) field( FTK, "ULONG" ) field( FTVK, "ULONG" )
	field( INPL, "0" ) field( FTL, "ULONG" ) field( FTVL, "ULONG" )
	field( INPM, "0" ) field( FTM, "ULONG" ) field( FTVM, "ULONG" )
	field( INPN, "0" ) field( FTN, "ULONG" ) field( FTVN, "ULONG" )
	field( INPO, "0" ) field( FTO, "ULONG" ) field( FTVO, "ULONG" )
	field( INPP, "0" ) field( FTP, "ULONG" ) field( FTVP, "ULONG" )
	field( INPQ, "0" ) field( FTQ, "ULONG" ) field( FTVQ, "ULONG" )
	field( INPR, "0" ) field( FTR, "ULONG" ) field( FTVR, "ULONG" )
	field( INPS, "0" ) field( FTS, "ULONG" ) field( FTVS, "ULONG" )
	field( INPT, "0" ) field( FTT, "ULONG" ) field( FTVT, "ULONG" )
	field( INPU, "0" ) field( FTU, "ULONG" ) field( FTVU, "ULONG" )
}

#
# NOTE: The following 3 records were added to support sharing the
# existing 14 $(EVR):EVENT4CTRL style records.
# New scheme adds $(TRIG):EVENTCTRL and uses that, avoiding the requirement
# for these, as the default will be to use the trigger specific $(TRIG):EVENTCTRL.
# For now I'm leaving them in in case we find that users are still sharing the
# same event ctrl record via the older screens.
#	$(TRIG):CTRL_N_OUTPUTS_ON
#	$(TRIG):CTRL_IS_SHARED_CALC
#	$(TRIG):CTRL_IS_SHARED
# also these 14
#	$(EVR):EVENT$(N)CTRL_N_OUTPUTS_ON

# PV to fetch the current number of enabled outputs for
# the control record specified by input Z.
# Processes whenever any of the 15 EVENT*CTRL_N_OUTPUTS_ON PV's updates
# Uses the LSUB_TRGSEL value to specify which control
# record's count to read
record( longSub, "$(TRIG):CTRL_N_OUTPUTS_ON" )
{
	field( DESC, "# outputs for this ctrl" )
	field( SCAN, "Passive" )
	field( INAM, "lsubEvSelInit" )
	field( SNAM, "lsubEvSel" )
	field( INPA, "$(TRIG):EVENTCTRL_N_OUTPUTS_ON CPP NMS" )
	field( INPB, "$(EVR):EVENT1CTRL_N_OUTPUTS_ON CPP NMS" )
	field( INPC, "$(EVR):EVENT2CTRL_N_OUTPUTS_ON CPP NMS" )
	field( INPD, "$(EVR):EVENT3CTRL_N_OUTPUTS_ON CPP NMS" )
	field( INPE, "$(EVR):EVENT4CTRL_N_OUTPUTS_ON CPP NMS" )
	field( INPF, "$(EVR):EVENT5CTRL_N_OUTPUTS_ON CPP NMS" )
	field( INPG, "$(EVR):EVENT6CTRL_N_OUTPUTS_ON CPP NMS" )
	field( INPH, "$(EVR):EVENT7CTRL_N_OUTPUTS_ON CPP NMS" )
	field( INPI, "$(EVR):EVENT8CTRL_N_OUTPUTS_ON CPP NMS" )
	field( INPJ, "$(EVR):EVENT9CTRL_N_OUTPUTS_ON CPP NMS" )
	field( INPK, "$(EVR):EVENT10CTRL_N_OUTPUTS_ON CPP NMS" )
	field( INPL, "$(EVR):EVENT11CTRL_N_OUTPUTS_ON CPP NMS" )
	field( INPM, "$(EVR):EVENT12CTRL_N_OUTPUTS_ON CPP NMS" )
	field( INPN, "$(EVR):EVENT13CTRL_N_OUTPUTS_ON CPP NMS" )
	field( INPO, "$(EVR):EVENT14CTRL_N_OUTPUTS_ON CPP NMS" )
	field( INPZ, "$(TRIG):LSUB_TRGSEL.VAL CPP NMS" )
	field( FLNK, "$(TRIG):CTRL_IS_SHARED_CALC" )
}

# PV to determine if this trigger shares it's control record
# with other outputs
record( calc, "$(TRIG):CTRL_IS_SHARED_CALC" )
{
	field( INPA, "$(TRIG):CTRL_N_OUTPUTS_ON NPP NMS" )
	field( INPB, "$(TRIG):TCTL CPP MS" )
	field( CALC, "B?(A>1):(A>0)" )
	field( PINI, "YES" )
	field( FLNK, "$(TRIG):CTRL_IS_SHARED" )
}

record( bo, "$(TRIG):CTRL_IS_SHARED" )
{
	field( DOL,  "$(TRIG):CTRL_IS_SHARED_CALC" )
	field( OMSL, "closed_loop" )
	field( ZNAM, "Private" )
	field( ONAM, "Shared" )
}
